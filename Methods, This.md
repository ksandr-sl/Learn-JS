**Methods, This**
-   Функции, которые находятся в объекте в качестве его свойств, называются «методами».
-   Методы позволяют объектам «действовать»: `object.doSomething()`.
-   Методы могут ссылаться на объект через `this`.
-   При объявлении любой функции в ней можно использовать `this`, но этот `this` не имеет значения до тех пор, пока функция не будет вызвана.
-   Эта функция может быть скопирована между объектами (из одного объекта в другой).
-   Когда функция вызывается синтаксисом «метода» – `object.method()`, значением `this` во время вызова является объект перед точкой.

**У стрелочных функций нет «this»**
Когда внутри стрелочной функции обращаются к `this`, то его значение берётся снаружи.

---
**Внутренняя реализация: Ссылочный тип**

Некоторые хитрые способы вызова метода приводят к потере значения `this`, например:
```js
let user = { 
	name: "Джон", 
	hi() { alert(this.name); },
	bye() { alert("Пока"); }
}; 

user.hi(); // Джон (простой вызов метода работает хорошо)

// теперь давайте попробуем вызывать user.hi или user.bye 
// в зависимости от имени пользователя user.name 
(user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!
```
*Для работы вызовов типа `user.hi()`, JavaScript использует трюк – точка `'.'` возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.*

Этот ссылочный тип является внутренним. Мы не можем явно использовать его, но он используется внутри языка.

Значение ссылочного типа – это «триплет»: комбинация из трёх значений `(base, name, strict)`, где:

-   `base` – это объект.
-   `name` – это имя свойства объекта.
-   `strict` – это режим исполнения. Является true, если действует строгий режим (`use strict`).

Результатом доступа к свойству `user.hi` является не функция, а значение ссылочного типа.
Для `user.hi` в строгом режиме оно будет таким:
```js
// значение ссылочного типа (Reference Type) 
(user, "hi", true)
```
Когда скобки `()` применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, и могут поставить правильный `this` (`=user` в данном случае, по `base`).

При любой другой операции, например, присваивании `hi = user.hi`, ссылочный тип заменяется на собственно значение `user.hi` (функцию), и дальше работа уже идёт только с ней. Поэтому дальнейший вызов происходит уже без `this`.





---
[[Objects]]